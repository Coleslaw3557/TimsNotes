# Auto renew and auto import a free Let's Encrypt Certificate on a Fortigate for SSL-VPN using APIs.

#### Tim Lister - 03.16.20

### Components:

* Certbot or Traefik to connect to Let's Encrypt and get a Certificate (I am using Traefik 2.x but unless you're already using it, Certbot is probably the way to go).
* Treafik-certs-dumper (if using Traefik) - https://github.com/ldez/traefik-certs-dumper
* Certbot (if using Certbot instead of Traefik) - https://certbot.eff.org/instructions
* Python 3.6
* Python program to connect to FG API and upload or replace certificate. - Matt Sheriff's original version here https://www.ultraviolet.network/post/let-s-encrypt-with-fortigate

### Certificate Generation:

I use Traefik as a reverse proxy with integration to Let's Encrypt API for auto certificate generation. The EFF tool Certbot would likely take this process' place in other installations.

If you are using CertBot, you can safely skip this step.

If using Traefik 2.x, use Traefik-certs-dump tool to get the certs out of acme.json and into .pem files
```
./traefik-certs-dumper file --version v2 --source ~/traefik/data/acme.json --domain-subdir --dest ./certs --crt-ext=.pem --key-ext=.pem
```

The above command will spit out the following:

```
certs/
|-- cert.info
|   |-- certificate.pem
|   `-- privatekey.pem
`-- private
    `-- letsencrypt.pem
```
This command should be added to a crontab or similar schedule to automatically convert json cert to .pem after your renewed certificate is generated by Traefik.

### Configure Fortigate API account and profile

You will likely want to create the api user and profile from the GUI. CLI is included as example config with least permissions required.

```
config system global
config system accprofile
	edit "CertBot Profile"
        set vpngrp read-write
  next

config system api-user
    edit "certbot"
        set api-key ENC xyz
        set accprofile "CertBot Profile"
        set vdom "DMZ"
        config trusthost
            edit 1
                set ipv4-trusthost <ip of your host running the script> 255.255.255.255
            next
        end
```

### Import Certificate to Fortigate using Fortinet's API:

The original python program was written by Matt Sheriff and is available here:
https://www.ultraviolet.network/post/let-s-encrypt-with-fortigate

The version below is modified slightly for support with VDOMs and further documentation.

While testing, see the log for errors. The errors codes can be compared to the Fortinet API documentation here:
https://fndn.fortinet.net/index.php?/fortiapi/1-fortios/# (login required)

You will need to create two python programs, one holds your config and the other is the script to connect to the API.

config.py contains the config to connect to one or multiple Fortigates:

```
#! /usr/bin/env python3

from datetime import date
from datetime import datetime

# Log file path - edit these to your liking
logfile_path = "./"
logfile_name = "certupdate{}.log".format(date.today())

# Certificate related variables
cert_name = "site.info"
cert_fullchain_file = "./certs/site.info/certificate.pem"
cert_privkey_file = "./certs/site.info/privatekey.pem"

# Fortigates to be updated - this is a python list, to add a new element just add a comma
# to the end of the } and start with a new dictionary
#
# example my_gates = [
# {
#     "hostname": "gate1.domain.local",
#     "key":"your_key_here",
#     "port": "8443",
#     "VerifyCert": False
# },{
#       "hostname": "gate2.domain.local",
#       "key":"your_key_here",
#       "port": "8443",
#       "VerifyCert": False
# }
# ]

my_gates = [
{
    "hostname": "fortigate-500e", # Add this to the systems hosts file. IP must reside in destination VDOM you want the certificate imported into.
    "host_ip":"replace-with-ip", # This IP Address must match what's in your hosts file.
    "key":"replace-with--FG-api-key",
    "port": "443",
    "VerifyCert": False
}
]

# Creating the JSON for the cert creation
cert_post_body = {
    "type": "regular",
    "certname": cert_name,
    "key_file_content": "",
    "scope": "vdomDMZ", # I'm not convinced this works but set your VDOM name here. Set to 'global' if not using VDOMS.
    "file_content": ""
}

# Creating the JSON for for assigning the cert as the system/admin cert
cert_system_assignment = {
    "admin-server-cert": cert_name
}
```

The second program is to connect to the Fortigate's API:

```
#! /usr/bin/env python3

import requests
import urllib3
import sys
from datetime import date
from datetime import datetime
import time
import os
from config import *


# Setting up some basic logging - nothing fancy, just need to keep track of what happens
def writelog(logmessage):
    # If the folder where the log file should be doesn't exist, create it
    if not os.path.exists(logfile_path):
        os.mkdir(logfile_path)

    with open("{}{}-{}".format(logfile_path, date.today(), logfile_name), "a+") as logfile:
        logfile.write("\n\r{}".format(logmessage))


def PrepareCert(cert_file):
    # Declaring some variables we'll be using to prepare our certs
    cert_list = []
    prepared_cert = ""

    with open(cert_file, "r") as file:
        for line in file.readlines():
            line = line.replace("\n", "")
            line = line.replace("\r", "")
            cert_list.append(line)

    # Remove the first and last lines of these lists
    cert_list.pop(0)
    cert_list.pop(-1)

    # Processing the cert as a continuous string - no line breaks
    for list_line in cert_list:
        prepared_cert = prepared_cert + list_line
    return prepared_cert

writelog(" ")
writelog("Starting Script {}".format(datetime.now()))

# Reading the cert files
writelog("Reading Certificate Files")

# Setting up our cert vairables
cert_fullchain = PrepareCert(cert_fullchain_file)
# This is important, the line break needs to be there for the full certificate chain
# Otherwise I just would prevent those from being added to the list in the PrepareCert function
# Open to other ways
cert_fullchain = cert_fullchain.replace("-----END CERTIFICATE----------BEGIN CERTIFICATE-----", "\n")

# Prepare the private key to be one long string
cert_privkey = PrepareCert(cert_privkey_file)

cert_post_body["file_content"]=cert_fullchain
cert_post_body["key_file_content"]=cert_privkey


# Now we get down to business - for each gate in the config file do the following
for gate in my_gates:
    # Setting up variables for ease of reading
    hostname = gate["hostname"]
    api_key = gate["key"]
    VerifyTrustedCert = gate["VerifyCert"]
    gate_port = gate["port"]

    writelog("Attempting to update the cert on {}".format(gate["hostname"]))
    access_url = "https://{}:{}/api/v2/cmdb/certificate/local/{}?access_token={}".format(hostname, gate_port, cert_name, api_key)
    writelog(access_url)
    # Check and see if the certificate exists
    response = requests.get(access_url, verify=VerifyTrustedCert)
    writelog("reponse code is: {}".format(response.status_code))
    # If the cert isn't present, then create it
    if response.status_code == 404:
        writelog("Could not find the cert - creating")

        # request and create the cert
        access_url = "https://{}:{}/api/v2/monitor/vpn-certificate/local/import?access_token={}".format(hostname, gate_port, api_key)
        writelog(access_url)
        writelog("cert_post_body equals: \n {}".format(cert_post_body))
        cert_update = requests.post(access_url, json=cert_post_body, verify=VerifyTrustedCert)
        writelog(cert_update.json())
        if cert_update.status_code == 200:
            writelog("Cert successfully installed, making default system cert")

            # assign the cert as the default for management gui
            access_url = "https://{}:{}/api/v2/cmdb/system/global?access_token={}".format(hostname, gate_port, api_key)
            writelog(access_url)
            writelog("cert assignment equals: \n {}".format(cert_system_assignment))
            try:
                cert_assignment = requests.put(access_url, json=cert_system_assignment, verify=VerifyTrustedCert)
                if cert_assignment.status_code == 200:
                    writelog("Cert successfully assigned as management cert")
                else:
                    writelog("An error occurred, the details are:\n {}".format(cert_system_assignment.text))
            except urllib3.exceptions.ProtocolError:
                current_settings = requests.get(access_url)
                print(current_settings.json()["results"]["admin-server-cert"])
            except requests.exceptions.ConnectionError:
                current_settings = requests.get(access_url)
                print(current_settings.json()["results"]["admin-server-cert"])
            except Exception as e:
                writelog("An error occurred, the details are:\n {}".format(e))
        else:
            writelog("An error occurred, the details are:\n {}".format(cert_update.text))
```

You will now have a valid certificate installation in your VDOM of choice and ready for SSL-VPN use.

Since Let's Encrypt certificates expire every three months, you will need to schedule the above commands (and possibly certbot) to execute before your cert expires.
